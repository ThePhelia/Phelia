diff --git a/discovery.py b/discovery.py
index 3b3b3b3..7c7c7c7 100644
--- a/discovery.py
+++ b/discovery.py
@@ -1,6 +1,7 @@
 from __future__ import annotations
 
 from typing import Any, Dict
+import httpx
 from fastapi import APIRouter, HTTPException
 
 router = APIRouter(prefix="/api/v1/discovery", tags=["discovery"])
@@
 DEFAULT_PROVIDER_STATUS = {
     "lastfm": False,
     "deezer": False,
@@
     "spotify": False,
 }
 
@@
 GENRE_SLUG_TO_MB_TAG: Dict[str, str] = {
     "ambient": "ambient",
     "classical": "classical",
@@
     "rock": "rock",
     "techno": "techno",
 }
+
+# --- NEW: Apple helpers -------------------------------------------------------
+# Best-effort mapping of UI slugs to Apple Music genre IDs.
+# Unknown slugs fall back to 0 (global charts).
+APPLE_SLUG_TO_ID: Dict[str, int] = {
+    "indie": 20,         # Alternative/Indie
+    "rock": 21,          # Rock
+    "metal": 1153,       # Metal
+    "pop": 14,           # Pop
+    "hip-hop": 18,       # Hip-Hop/Rap
+    "hiphop": 18,
+    "electronic": 7,     # Electronic umbrella
+    "house": 7,          # Electronic umbrella
+    "techno": 7,         # Electronic umbrella
+    "ambient": 7,        # Electronic umbrella
+    "jazz": 11,          # Jazz
+    "classical": 5,      # Classical
+    "dnb": 7,
+    "drum-and-bass": 7,
+}
+
+# Apple RSS uses "most-played" where our UI sends "most-recent".
+APPLE_FEED_ALIAS: Dict[str, str] = {
+    "most-recent": "most-played",
+}
+# ----------------------------------------------------------------------------- 
 
@@
 async def new_albums(
     genre: str,
     limit: int = 30,
     days: int = 30,
 ) -> Dict[str, Any]:
@@
-    # MusicBrainz fallback (no keys required)
-    if not aggregate:
-        query = f'tag:"{mb_tag}" AND primarytype:Album AND firstreleasedate:[{since} TO *]'
-        data = await _mb_get_json(
-            "https://musicbrainz.org/ws/2/release-group",
-            {"query": query, "fmt": "json", "limit": str(limit), "offset": "0"},
-        )
-        for rg in data.get("release-groups", []):
-            aggregate.append(
-                {
-                    "id": rg.get("id"),
-                    "title": rg.get("title"),
-                    "artist": (rg.get("artist-credit") or [{}])[0].get("name"),
-                    "releaseDate": rg.get("first-release-date"),
-                    "cover": f"https://coverartarchive.org/release-group/{rg.get('id')}/front-250",
-                    "source": "musicbrainz",
-                }
-            )
+    # MusicBrainz fallback (no keys required). Swallow MB 5xx to avoid UI 503.
+    if not aggregate:
+        try:
+            query = f'tag:"{mb_tag}" AND primarytype:Album AND firstreleasedate:[{since} TO *]'
+            data = await _mb_get_json(
+                "https://musicbrainz.org/ws/2/release-group",
+                {"query": query, "fmt": "json", "limit": str(limit), "offset": "0"},
+            )
+            for rg in data.get("release-groups", []):
+                aggregate.append(
+                    {
+                        "id": rg.get("id"),
+                        "title": rg.get("title"),
+                        "artist": (rg.get("artist-credit") or [{}])[0].get("name"),
+                        "releaseDate": rg.get("first-release-date"),
+                        "cover": f"https://coverartarchive.org/release-group/{rg.get('id')}/front-250",
+                        "source": "musicbrainz",
+                    }
+                )
+        except HTTPException as exc:
+            if exc.status_code >= 500:
+                aggregate = []
+            else:
+                raise
 
     payload = _prepare_payload(aggregate, limit)
     return payload
 
@@
 async def top_albums(
     genre: str | None = None,
     kind: str = "albums",
     feed: str = "most-recent",
     limit: int = 30,
     genre_id: int | None = None,
 ) -> Dict[str, Any]:
@@
-    apple_fn = globals().get("apple_feed")
+    apple_fn = globals().get("apple_feed")
     if callable(apple_fn):
         try:
             storefront = getattr(settings, "APPLE_RSS_STOREFRONT", "us")
-            genre_key = genre_id if genre_id is not None else 0
-            items = apple_fn(storefront, genre_key, feed, kind, limit)
+            # Prefer explicit id, else map slug -> Apple id, else 0 (global).
+            genre_key = genre_id if genre_id is not None else APPLE_SLUG_TO_ID.get((genre or "").lower(), 0)
+            # Normalize feed names for Apple.
+            apple_feed_name = APPLE_FEED_ALIAS.get(feed, feed)
+            items = apple_fn(storefront, genre_key, apple_feed_name, kind, limit)
             aggregate.extend(_normalize_items(_iter_items(items or [])))
-        except Exception as exc:  # pragma: no cover - provider specific
+        except httpx.HTTPError:
+            # Network/HTTP error on Apple â€“ just skip to MB fallback.
+            pass
+        except Exception as exc:  # pragma: no cover - provider specific
             raise HTTPException(status_code=502, detail=f"Apple RSS error: {exc}")
@@
-    if not aggregate and tag:
-        ar = await _mb_get_json(
-            "https://musicbrainz.org/ws/2/artist",
-            {"query": f'tag:"{tag}"', "fmt": "json", "limit": str(min(50, max(10, limit * 2)))},
-        )
-        for a in ar.get("artists", []):
-            rg = await _mb_get_json(
-                "https://musicbrainz.org/ws/2/release-group",
-                {"query": f'artist:{a.get("id")} AND primarytype:Album', "fmt": "json", "limit": "1"},
-            )
-            rj = rg.get("release-groups", [])
-            if not rj:
-                continue
-            rg0 = rj[0]
-            aggregate.append(
-                {
-                    "id": rg0.get("id"),
-                    "title": rg0.get("title"),
-                    "artist": a.get("name"),
-                    "releaseDate": rg0.get("first-release-date"),
-                    "cover": f'https://coverartarchive.org/release-group/{rg0.get("id")}/front-250',
-                    "source": "musicbrainz",
-                }
-            )
-            if len(aggregate) >= limit:
-                break
+    if not aggregate and tag:
+        try:
+            ar = await _mb_get_json(
+                "https://musicbrainz.org/ws/2/artist",
+                {"query": f'tag:"{tag}"', "fmt": "json", "limit": str(min(50, max(10, limit * 2)))},
+            )
+            for a in ar.get("artists", []):
+                rg = await _mb_get_json(
+                    "https://musicbrainz.org/ws/2/release-group",
+                    {"query": f'artist:{a.get("id")} AND primarytype:Album', "fmt": "json", "limit": "1"},
+                )
+                rj = rg.get("release-groups", [])
+                if not rj:
+                    continue
+                rg0 = rj[0]
+                aggregate.append(
+                    {
+                        "id": rg0.get("id"),
+                        "title": rg0.get("title"),
+                        "artist": a.get("name"),
+                        "releaseDate": rg0.get("first-release-date"),
+                        "cover": f'https://coverartarchive.org/release-group/{rg0.get("id")}/front-250',
+                        "source": "musicbrainz",
+                    }
+                )
+                if len(aggregate) >= limit:
+                    break
+        except HTTPException as exc:
+            if exc.status_code >= 500:
+                aggregate = []
+            else:
+                raise

